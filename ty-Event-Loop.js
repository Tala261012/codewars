//* Цикл событий

/*
    ** setTimeout позволяет вызвать функцию ОДИН РАЗ через определённый интервал времени.
    ** setInterval позволяет вызывать функцию РЕГУЛЯРНО, 
		повторяя вызов через определённый интервал времени.

? setTimeout(callback, delay?, arg1?, ..., argN?) =========================
ВОЗВРАЩАЕТ id
let timerId = setTimeout(callback, delay?, ...);

callback - Функция или строка кода для выполнения. Обычно это функция 
		(стрелочная или ее имя, без запуска, т е без скобок). 
		По историческим причинам можно передать и строку кода (в обычных кавычках), но это не рекомендуется.
delay (необяз) - Задержка перед запуском в миллисекундах (1000 мс = 1 с). По умолчанию – 0.
arg1, ... - Аргументы, передаваемые в функцию
? clearTimeout(id)
setTimeout возвращает «идентификатор таймера» timerId, 
который можно использовать для отмены дальнейшего выполнения.
let timerId = setTimeout(...);
clearTimeout(timerId);
*/
let timerId = setTimeout(() => console.log("ничего не происходит"), 1000);
console.log(timerId); // идентификатор таймера

clearTimeout(timerId);
console.log(timerId);
// тот же идентификатор (объект) (не принимает значение null после отмены, свойства изменяются
// в браузере это число, а не объект

/*
? setInterval(callback, delay?, arg1?, ..., argN?)
ВОЗВРАЩАЕТ timerId, те же аргументы, запускается регулярно, через delay миллисекунд
Часы тикают постоянно, время выполнения callback не влияет на следующий запуск callback
(чтобы этого избежать используют вложенный setTimeout, см. ниже)
? clearInterval(timerId)
setInterval работает, пока не будет вызван clearInterval, 
при этом callback и ее лексическое окружение остаются в памяти (до вызова clearInterval)
*/

// пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:
// повторить с интервалом 2 секунды
let timerId2 = setInterval(() => console.log("tick"), 2000);

// остановить вывод через 5 секунд
setTimeout(() => {
  clearInterval(timerId2);
  console.log("stop");
}, 5000);

/*
? setImmediate(callback, delay?, arg1?, ..., argN?)
планирует выполнение функции сразу после завершения текущей фазы событий
Event Loop, но перед следующей фазой. Возвращает timerId.
У setTimeout приоритет выше
? clearImmediate(id)
*/

//? Вложенный setTimeout =========================
// https://learn.javascript.ru/settimeout-setinterval#vlozhennyy-settimeout

/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId3 = setTimeout(function tick() {
  console.log("tick-tak");
  timerId3 = setTimeout(tick, 2000); // (*)
}, 2000); // вечное выполнение
/* Вложенный setTimeout – более гибкий метод, чем setInterval. 
С его помощью последующий вызов может быть задан по-разному 
в зависимости от результатов предыдущего. 
Вложенный setTimeout позволяет задать задержку между выполнениями 
более точно, чем setInterval.
*/

//? setTimeout с нулевой задержкой ================
/*
Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func).
Это планирует вызов func настолько быстро, насколько это возможно. 
Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.
Так вызов функции будет запланирован сразу после выполнения текущего кода.
*/
