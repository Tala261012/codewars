/* 
* new Promise
– это специальный объект в JavaScript, 
который связывает «создающий» и «потребляющий» коды вместе. 

let promise = new Promise(function(resolve, reject) {
...
});

Анонимная функция называется исполнитель (executor), запускается автоматически сразу же.
Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. 
Наш код – только внутри исполнителя.
Когда получен результат, он должен вызвать или resolve(value) (value - результат),
или reject(error) (error - объект ошибки)

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
? state («состояние») 
вначале "pending" («ожидание»), 
потом меняется на "fulfilled" («выполнено успешно») при вызове resolve 
или на "rejected" («выполнено с ошибкой») при вызове reject.
? result («результат») 
вначале undefined, 
далее изменяется на value при вызове resolve(value) 
или на error при вызове reject(error).

Состояние промиса может быть изменено только один раз (или resolve, или reject).

resolve/reject ожидает только один аргумент (или ни одного)

? .then
promise.then(
  function(result) {} // обработает успешное выполнение ,
  function(error) {} // обработает ошибку 
);
? .catch
.catch(f) это то же самое, что promise.then(null, f)
? .finally
— не имеет аргументов, 
— не предназначен для обработки результата промиса,
— не должен ничего возвращать (будет проигнорировано)
Единственным исключением из этого является случай, когда обработчик finally выдает ошибку

new Promise((resolve, reject) => {
	сделать что-то, что займёт время, и после вызвать resolve или может reject 
})
	выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
  .then(result => показать результат, err => показать ошибку)
*/
function loadScript(src) {
  return new Promise(function (resolve, reject) {
    let script = document.createElement("script");
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));

    document.head.append(script);
  });
}

// Применение:
let promise = loadScript(
  "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"
);

promise.then(
  (script) => alert(`${script.src} загружен!`),
  (error) => alert(`Ошибка: ${error.message}`)
);

promise.then((script) => alert("Ещё один обработчик..."));

/*
? Цепочка вызовов .then
вызов promise.then тоже возвращает промис, 
так что мы можем вызвать на нём следующий .then

можно в .then также возвращать промис - получится цепочка асинхронных действий.
return new Promise(resolve, reject) => {}

.then также перехватывает ошибки, если задан второй аргумент 
(который является обработчиком ошибок). См. пример ниже (*)

? catch
Строки кода (*)
promise.then(f1).catch(f2); (1)
и 
promise.then(f1, f2); (2)
НЕ эквивалентны - если ошибка произойдёт в f1 (1), то она будет обработана в .catch
.then передаёт результат или ошибку следующему блоку .then/catch

Мы можем иметь столько обработчиков .then, сколько мы хотим, 
и затем использовать один .catch в конце, чтобы перехватить ошибки из всех обработчиков.

.catch перехватывает все виды ошибок в промисах: 
будь то вызов reject() или ошибка, брошенная в обработчике при помощи throw.

? unhandledrejection
В браузере - гобальная ошибка. Это событие является частью стандарта HTML.
Если происходит ошибка, и отсутствует её обработчик, то генерируется событие unhandledrejection, 
и соответствующий объект event содержит информацию об ошибке.
*/
window.addEventListener("unhandledrejection", function (event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function () {
  throw new Error("Ошибка!");
}); // нет обработчика ошибок

/*
* Методы Promise ================================================================

? let promise = Promise.all(iterable)
все или ничего
принимает массив промисов (любой перебираемый объект) 
возвращает промис, массив результатов после выполнения всех.
порядок элементов массива в точности соответствует порядку исходных промисов
Например, так можно параллельно загрузить несколько файлов и обработать результат, когда он готов.

Если любой из промисов завершится с ошибкой, 
то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.
В случае ошибки, остальные результаты игнорируются.

Разрешено передавать не-промисы в iterable (перебираемом объекте), 
они будут переданы итоговый массив «как есть»

? let promise = Promise.allSettled(iterable);
Метод Promise.allSettled всегда ждёт завершения всех промисов. 
В массиве объектов-результатов будет
{status:"fulfilled", value:результат} для успешных завершений,
{status:"rejected", reason:ошибка} для ошибок.

? let promise = Promise.race(iterable);
похож на Promise.all, но ждёт только ПЕРВЫЙ выполненный промис, 
из которого берёт результат (или ошибку).
После этого остальные промисы игнорируются.

? let promise = Promise.any(iterable);
Метод очень похож на Promise.race, но ждёт только ПЕРВЫЙ УСПЕШНО ВЫПОЛНЕННЫЙ  промис, 
из которого берёт результат.
Если ни один из переданных промисов не завершится успешно, 
тогда возвращённый объект Promise будет отклонён с помощью 
? AggregateError 
– специального объекта ошибок, который хранит все ошибки промисов 
в своём свойстве errors (это массив).

? Promise.resolve(value)
создаёт успешно выполненный промис с результатом value.
То же самое, что:
let promise = new Promise(resolve => resolve(value));

? Promise.reject(error)
создаёт промис, завершённый с ошибкой error.
То же самое, что:
let promise = new Promise((resolve, reject) => reject(error));
*/

/*
? Промисификация
Это преобразование -  берём функцию, которая принимает колбэк и меняем её, 
чтобы она вместо этого возвращала промис.

? Обработка промисов всегда асинхронная, 
т.к. все действия промисов проходят через специальную внутреннюю очередь «promise jobs», 
так называемую «очередь микрозадач (microtask queue)» (термин V8).

Обработчики .then/catch/finally вызываются после выполнения промиса.

Если нужно гарантировать выполнение кода после .then/catch/finally, 
то лучше всего добавить его вызов в цепочку .then.
*/

/*
 * async/await ===================================================================
Это синтаксический сахар для promise.then

async function f() {
  return 1;
}
f().then(alert); // 1

? async 
- такая функция всегда возвращает промис. 
Значения других типов оборачиваются в завершившийся успешно промис автоматически.
? await
- работает ТОЛЬКО внутри async–функций
- заставляет интерпретатор JavaScript ждать до тех пор, 
пока промис справа от await не выполнится. 
После чего оно вернёт его результат, ТОЛЬКО ТЕПЕРЬ выполнение кода продолжится.

await работает с «thenable»–объектами

У классав могут быть асинхронные методы:

class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}
new Waiter()
  .wait()
  .then(alert); // 1

? ошибки
В случае возникновения (ожидания) ошибок следует использовать обчный
try..catch
как с обычным throw

Если нет try..catch, асинхронная функция будет возвращать завершившийся с ошибкой 
промис (в состоянии rejected). Тут можно использовать метод .catch промиса, 
чтобы обработать ошибку:

async function f() {}
f().catch(alert);

async/await отлично работает с Promise.all:
let results = await Promise.all([..])
*/
