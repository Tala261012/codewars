//* Object

/*
? Object.assign(target, src1, ..., srcN)
- копирует свойства и методы объектов src1, ..., srcN в target
- возвращает новый объект
- если названия свойств совпадают - они перезаписываются
- символьные свойства также копируются
- если свойство содержит вложенный объект - копируется ССЫЛКА! (глубокое клонирование: _.cloneDeep(obj) из библиотеки JavaScript lodash. Или  глобальный метод structuredClone())

Можно и так:
let user = {name: "John", age: 30};
let clone = Object.assign({}, user); 
*/

/* 
? Object.keys(obj) 
– возвращает массив ключей. Без символьных свойств.
? Object.values(obj) 
– возвращает массив значений. Без символьных свойств.
? Object.entries(obj) 
– возвращает массив пар [ключ, значение]. Без символьных свойств.
? Object.fromEntries(arr) 
- получив массив пар вида [ключ, значение], он создаёт из них объект

? for..in
- Без символьных свойств.

? Object.getOwnPropertySymbols(obj)
– с его помощью можно получить все свойства объекта с ключами-символами (только с ключами-символами).
Также существует метод
? Reflect.ownKeys(obj),
который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны.
*/

/*
? .hasOwnProperty(prop)
- имеет ли объект свойство prop
- true/false
- видит символьные свойства
? Object.is(obj1.prop, obj2.prop)
- проверка на строгое равенство между двумя значениями
- true/false
- видит символьные свойства
*/

/*
? new.target
Это специальное свойство внутри функции, так мы можем проверить, 
вызвана ли функция при помощи оператора new или без него.
- возвращает undefined/сама функция

? return в конструкторе
- обычно его нет, возвращается все, что записатно у this
- если же return есть, то:
	-- При вызове return с объектом, вместо this вернётся объект.
	-- При вызове return с примитивным значением, оно проигнорируется.
*/

/*
* Опциональная цепочка '?.' =====================================================
Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам объекта.
останавливает вычисление и возвращает undefined, 
если значение перед ?. равно undefined или null. НО переменная существует (let, const)

let user = {}; 
console.log( user?.address?.street ); // undefined (без ошибки)

- obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
- obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
- obj.method?.() – вызывает obj.method(), если obj.method существует, 
в противном случае возвращает undefined, ничего не запускает.

? C delete
delete user?.name; // удаляет user.name если пользователь существует
Если объекта user нет - ошибка

Мы можем использовать ?. для безопасного ЧТЕНИЯ и УДАЛЕНИЯ, но не для записи !!!
=================================================================================
*/

/*
* Флаги (атрибуты) и дескрипторы свойств ========================================
Дескрипторы свойств работают на уровне конкретных свойств.
? writable 
– если true, свойство можно изменить, иначе оно только для чтения.
? enumerable 
– если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
? configurable 
– если true, свойство можно удалить, а эти атрибуты можно изменять, 
иначе этого делать нельзя.

? Object.getOwnPropertyDescriptor
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
- возвращает объект - «дескриптор свойства», содержит значение свойства и все его флаги.

Для свойств объектов, созданных "обычным" способом это так:
{
  "value": "John",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
? Object.getOwnPropertyDescriptors(obj)
- получить все дескрипторы свойств сразу
- этот метод можно использовать для клонирования объекта вместе с его флагами:
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));

? Object.defineProperty(obj, propertyName, descriptor)
Если свойство существует, defineProperty обновит его флаги. 
В противном случае метод создаёт новое свойство с указанным значением и флагами; 
если какой-либо флаг не указан явно, ему присваивается значение false.

Для НОВОГО свойства необходимо ЯВНО указывать все флаги, для которых значение true

Пример 1 --------------------------------
let user = {};
Object.defineProperty(user, "name", {
  value: "John"
});

Пример 2 --------------------------------
let user = {
  name: "John"
};
Object.defineProperty(user, "name", {
  writable: false
});
user.name = "Pete"; // Ошибка: Невозможно изменить доступное только для чтения свойство 'name'
------------------------------------------

Неперечислимые свойства также не возвращаются Object.key !!!
Определение свойства как неконфигурируемого – это дорога в один конец. 
Мы не сможем изменить его обратно с помощью defineProperty. !!!
?  Object.defineProperties(obj, descriptors)
- позволяет определять множество свойств сразу.
Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false },
});

? .propertyIsEnumerable(prop)
проверяет, будет ли свойство появляться при итерации for..in
prop - строка или символ
true/false
*/

/*
 * Глобальное запечатывание объекта =============================================
Эти методы, которые ограничивают доступ ко всему объекту, 
а не на уровне конкретных свойств как дескрипторы
? Object.preventExtensions(obj)
Запрещает добавлять новые свойства в объект
? Object.isExtensible(obj)
Можно ли доваблять новые свойства? true/false

? Object.seal(obj)
Запрещает добавлять/удалять свойства. (Запечатывание)
Устанавливает configurable: false для всех существующих свойств.
? Object.isSealed(obj)
Возвращает true, если добавление/удаление свойств запрещено 
и для всех существующих свойств установлено configurable: false.
если было выполнено Object.preventExtensions(obj) - тоже false (не нормальный)

? Object.freeze(obj)
Запрещает добавлять/удалять/изменять свойства. 
Устанавливает configurable: false, writable: false для всех существующих свойств.
? Object.isFrozen(obj)
Является ли объкет замороженным? true/false
Возвращает true, если добавление/удаление/изменение свойств запрещено, 
и для всех текущих свойств установлено configurable: false, writable: false.
*/

/*
* Cвойства-аксессоры (accessor properties) ======================================
По своей сути это функции, которые используются для присвоения set 
и получения get значения, но во внешнем коде они выглядят как обычные свойствa.
При литеральном объявлении объекта они обозначаются get и set:
? get propName() {}
? set propName(value) {}

Свойство объекта может быть либо свойством-аксессором (с методами get/set), 
либо свойством-данным (со значением value). ИЛИ-ИЛИ
*/
let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  },
};

console.log(user.fullName); // John Smith
user.fullName = "Ivan Petrov";
console.log(user.name); // Ivan
console.log(user.surname); // Petrov
/* В итоге мы получили «виртуальное» свойство fullName. 
Его можно прочитать и изменить.

Дескрипторы свойств-аксессоров:
get – функция без аргументов, которая сработает при чтении свойства,
set – функция, принимающая один аргумент, вызываемая при присвоении свойства,
enumerable – то же самое, что и для свойств-данных,
configurable – то же самое, что и для свойств-данных.

Создание аксессора fullName при помощи defineProperty:
Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

? _property
существует широко известное соглашение о том, что свойства, 
которые начинаются с символа "_", являются внутренними, 
и к ним не следует обращаться из-за пределов объекта.
*/
