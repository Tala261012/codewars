//* Object

/*
? Object.assign(target, src1, ..., srcN)
- копирует свойства и методы объектов src1, ..., srcN в target
- возвращает новый объект
- если названия свойств совпадают - они перезаписываются
- символьные свойства также копируются
- если свойство содержит вложенный объект - копируется ССЫЛКА! (глубокое клонирование: _.cloneDeep(obj) из библиотеки JavaScript lodash. Или  глобальный метод structuredClone())

Можно и так:
let user = {name: "John", age: 30};
let clone = Object.assign({}, user); 
*/

/* 
? Object.keys(obj) 
– возвращает массив ключей. Без символьных свойств.
? Object.values(obj) 
– возвращает массив значений. Без символьных свойств.
? Object.entries(obj) 
– возвращает массив пар [ключ, значение]. Без символьных свойств.
? Object.fromEntries(arr) 
- получив массив пар вида [ключ, значение], он создаёт из них объект

? for..in
- Без символьных свойств.

? Object.getOwnPropertySymbols(obj)
– с его помощью можно получить все свойства объекта с ключами-символами (только с ключами-символами).
Также существует метод
? Reflect.ownKeys(obj),
который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны.
*/

/*
? .hasOwnProperty(prop)
- имеет ли объект свойство prop
- true/false
- видит символьные свойства
? Object.is(obj1.prop, obj2.prop)
- проверка на строгое равенство между двумя значениями
- true/false
- видит символьные свойства
*/

/*
? new.target
Это специальное свойство внутри функции, так мы можем проверить, 
вызвана ли функция при помощи оператора new или без него.
- возвращает undefined/сама функция

? return в конструкторе
- обычно его нет, возвращается все, что записатно у this
- если же return есть, то:
	-- При вызове return с объектом, вместо this вернётся объект.
	-- При вызове return с примитивным значением, оно проигнорируется.
*/

/*
* Опциональная цепочка '?.' =====================================================
Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам объекта.
останавливает вычисление и возвращает undefined, 
если значение перед ?. равно undefined или null. НО переменная существует (let, const)

let user = {}; 
console.log( user?.address?.street ); // undefined (без ошибки)

- obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
- obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
- obj.method?.() – вызывает obj.method(), если obj.method существует, 
в противном случае возвращает undefined, ничего не запускает.

? C delete
delete user?.name; // удаляет user.name если пользователь существует
Если объекта user нет - ошибка

Мы можем использовать ?. для безопасного ЧТЕНИЯ и УДАЛЕНИЯ, но не для записи !!!
=================================================================================
*/

/*
* Флаги (атрибуты) и дескрипторы свойств ========================================

Дескрипторы свойств работают на уровне конкретных свойств.
? writable 
– если true, свойство можно изменить, иначе оно только для чтения.
? enumerable 
– если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
? configurable 
– если true, свойство можно удалить, а эти атрибуты можно изменять, 
иначе этого делать нельзя.

? Object.getOwnPropertyDescriptor
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
- возвращает объект - «дескриптор свойства», содержит значение свойства и все его флаги.

Для свойств объектов, созданных "обычным" способом это так:
{
  "value": "John",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
? Object.getOwnPropertyDescriptors(obj)
- получить все дескрипторы свойств сразу
- этот метод можно использовать для клонирования объекта вместе с его флагами:
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));

? Object.defineProperty(obj, propertyName, descriptor)
Если свойство существует, defineProperty обновит его флаги. 
В противном случае метод создаёт новое свойство с указанным значением и флагами; 
если какой-либо флаг не указан явно, ему присваивается значение false.

Для НОВОГО свойства необходимо ЯВНО указывать все флаги, для которых значение true

Пример 1 --------------------------------
let user = {};
Object.defineProperty(user, "name", {
  value: "John"
});

Пример 2 --------------------------------
let user = {
  name: "John"
};
Object.defineProperty(user, "name", {
  writable: false
});
user.name = "Pete"; // Ошибка: Невозможно изменить доступное только для чтения свойство 'name'
------------------------------------------

Неперечислимые свойства также не возвращаются Object.key !!!
Определение свойства как неконфигурируемого – это дорога в один конец. 
Мы не сможем изменить его обратно с помощью defineProperty. !!!
?  Object.defineProperties(obj, descriptors)
- позволяет определять множество свойств сразу.
Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false },
});

? .propertyIsEnumerable(prop)
проверяет, будет ли свойство появляться при итерации for..in
prop - строка или символ
true/false
*/

/*
 * Глобальное запечатывание объекта =============================================
Эти методы, которые ограничивают доступ ко всему объекту, 
а не на уровне конкретных свойств как дескрипторы
? Object.preventExtensions(obj)
Запрещает добавлять новые свойства в объект
? Object.isExtensible(obj)
Можно ли доваблять новые свойства? true/false

? Object.seal(obj)
Запрещает добавлять/удалять свойства. (Запечатывание)
Устанавливает configurable: false для всех существующих свойств.
? Object.isSealed(obj)
Возвращает true, если добавление/удаление свойств запрещено 
и для всех существующих свойств установлено configurable: false.
если было выполнено Object.preventExtensions(obj) - тоже false (не нормальный)

? Object.freeze(obj)
Запрещает добавлять/удалять/изменять свойства. 
Устанавливает configurable: false, writable: false для всех существующих свойств.
? Object.isFrozen(obj)
Является ли объкет замороженным? true/false
Возвращает true, если добавление/удаление/изменение свойств запрещено, 
и для всех текущих свойств установлено configurable: false, writable: false.
*/

/*
* Cвойства-аксессоры (accessor properties) ======================================
По своей сути это функции, которые используются для присвоения set 
и получения get значения, но во внешнем коде они выглядят как обычные свойствa.
При литеральном объявлении объекта они обозначаются get и set:
? get propName() {}
? set propName(value) {}

Свойство объекта может быть либо свойством-аксессором (с методами get/set), 
либо свойством-данным (со значением value). ИЛИ-ИЛИ
*/
let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  },
};

console.log(user.fullName); // John Smith
user.fullName = "Ivan Petrov";
console.log(user.name); // Ivan
console.log(user.surname); // Petrov
/* В итоге мы получили «виртуальное» свойство fullName. 
Его можно прочитать и изменить.

Дескрипторы свойств-аксессоров:
get – функция без аргументов, которая сработает при чтении свойства,
set – функция, принимающая один аргумент, вызываемая при присвоении свойства,
enumerable – то же самое, что и для свойств-данных,
configurable – то же самое, что и для свойств-данных.

Создание аксессора fullName при помощи defineProperty:
Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

? _property
существует широко известное соглашение о том, что свойства, 
которые начинаются с символа "_", являются внутренними, 
и к ним не следует обращаться из-за пределов объекта.
*/

/*
* Прототипное наследование ======================================================

? .__proto__  ===================================================================
[[Prototype]] - специальное скрытое свойство, которое равно
- либо null
- либо ссылается на другой объект

Свойство __proto__ — это геттер/сеттер для [[Prototype]]:
let rabbit = {
  jumps: true,
  __proto__: animal
};

Объекты наследуют свойства и методы своих прототипов. Цепочка наследования может быть длинной.
Может быть ТОЛЬКО ОДИН [[Prototype]] !!!

Прототип используется только для ЧТЕНИЯ свойств !!! 
Операции записи/удаления работают непосредственно с объектом, 
они не используют прототип (если это обычное свойство, а не сеттер).

Свойство __proto__ считается устаревшим, 
и по стандарту оно должно поддерживаться только браузерами.

? При вызове метода this — всегда объект перед точкой.
А не прототип.

? for...in VS Object.keys, Object.values, ...
for..in проходит не только по собственным, но и по унаследованным свойствам.
Остальные методы получения ключей/значений работают только с собственными свойствами.

?obj.hasOwnProperty(key)
возвращает true, если у obj есть СОБСТВЕННОЕ, а не унаследованное, свойство с именем key.
=================================================================================

? .prototype    .constructor ====================================================
По умолчанию "prototype" – объект с единственным свойством constructor, 
которое ссылается на функцию-конструктор.
function Rabbit() {}

по умолчанию:
Rabbit.prototype = { constructor: Rabbit }

console.log( Rabbit.prototype.constructor == Rabbit ); // true
*/
function Rabbit(name) {
  this.name = name;
  console.log(name);
}
// по умолчанию:
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit("White"); // White
console.log(rabbit.constructor == Rabbit); // true (свойство получено из прототипа)

let rabbit2 = new rabbit.constructor("Black"); // TODO трюк
/*
Это ВЫЗОВ того конструктора, с помощью которого был создан rabbit, трюк
По умолчанию все функции имеют F.prototype = { constructor: F },
поэтому мы можем получить конструктор объекта через свойство "constructor".
https://learn.javascript.ru/function-prototype#sozdayte-novyy-obekt-s-pomoschyu-uzhe-suschestvuyuschego

F.prototype используется ТОЛЬКО в момент вызова new F !!!

Чтобы сохранить ВЕРНОЕ свойство "constructor", мы должны добавлять/удалять/изменять 
свойства у прототипа по умолчанию вместо того, чтобы перезаписывать его целиком:
function Rabbit() {}
Rabbit.prototype.jumps = true
=================================================================================

? Заимствование у прототипов
псевдоиассив:
let obj = {
  0: "Hello",
  1: "world!",
  length: 2,
	(*)
};

obj.join = Array.prototype.join;

console.log(obj.join(",")); // Hello,world!

или унаследовать методы массива, установив объекту свойство __proto__
{...
	__proto__: Array.prototype, (*)
...
}
=================================================================================

? Методы, которые нужно использовать вместо __proto__ ===========================

? Object.create(proto, descriptors?) 
– создаёт пустой объект со свойством [[Prototype]], указанным как proto, 
и необязательными дескрипторами свойств descriptors.

Мы можем создавать объекты без прототипов с помощью Object.create(null).

? Object.getPrototypeOf(obj) 
– возвращает свойство [[Prototype]] объекта obj.

? Object.setPrototypeOf(obj, proto) 
– устанавливает свойство [[Prototype]] объекта obj как proto.

let animal = {
  eats: true
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});

console.log(rabbit.jumps); // true

? Клонирование:
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));

Такой вызов создаёт точную копию объекта obj, включая все свойства: 
перечисляемые и неперечисляемые, геттеры/сеттеры для свойств – и всё это с правильным свойством [[Prototype]].

Эти методы возвращают «собственные» свойства (не унаследованные)
? Object.keys(obj) / Object.values(obj) / Object.entries(obj) 
– возвращают массив всех перечисляемых собственных строковых 
ключей/значений/пар ключ-значение.
? Object.getOwnPropertySymbols(obj) 
– возвращает массив всех собственных символьных ключей.
? Object.getOwnPropertyNames(obj) 
– возвращает массив всех собственных строковых ключей.
? Reflect.ownKeys(obj) 
– возвращает массив всех собственных ключей.
? obj.hasOwnProperty(key)
- возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.

Возвращает усе унаследованное - цикл
? for..in

*/
