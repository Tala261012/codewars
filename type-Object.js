//* Object

/*
? Object.assign(target, src1, ..., srcN)
- копирует свойства и методы объектов src1, ..., srcN в target
- возвращает новый объект
- если названия свойств совпадают - они перезаписываются
- символьные свойства также копируются
- если свойство содержит вложенный объект - копируется ССЫЛКА! (глубокое клонирование: _.cloneDeep(obj) из библиотеки JavaScript lodash. Или  глобальный метод structuredClone())

Можно и так:
let user = {name: "John", age: 30};
let clone = Object.assign({}, user); 
*/

/* 
? Object.keys(obj) 
– возвращает массив ключей. Без символьных свойств.
? Object.values(obj) 
– возвращает массив значений. Без символьных свойств.
? Object.entries(obj) 
– возвращает массив пар [ключ, значение]. Без символьных свойств.
? Object.fromEntries(arr) 
- получив массив пар вида [ключ, значение], он создаёт из них объект

? for..in
- Без символьных свойств.

? Object.getOwnPropertySymbols(obj)
– с его помощью можно получить все свойства объекта с ключами-символами (только с ключами-символами).
Также существует метод
? Reflect.ownKeys(obj),
который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны.
*/

/*
? .hasOwnProperty(prop)
- имеет ли объект свойство prop
- true/false
- видит символьные свойства
? Object.is(obj1.prop, obj2.prop)
- проверка на строгое равенство между двумя значениями
- true/false
- видит символьные свойства
*/

/*
? new.target
Это специальное свойство внутри функции, так мы можем проверить, 
вызвана ли функция при помощи оператора new или без него.
- возвращает undefined/сама функция

? return в конструкторе
- обычно его нет, возвращается все, что записатно у this
- если же return есть, то:
	-- При вызове return с объектом, вместо this вернётся объект.
	-- При вызове return с примитивным значением, оно проигнорируется.
*/

/*
* Опциональная цепочка '?.' =====================================================
Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам объекта.
останавливает вычисление и возвращает undefined, 
если значение перед ?. равно undefined или null. НО переменная существует (let, const)

let user = {}; 
console.log( user?.address?.street ); // undefined (без ошибки)

- obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
- obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
- obj.method?.() – вызывает obj.method(), если obj.method существует, 
в противном случае возвращает undefined, ничего не запускает.

? C delete
delete user?.name; // удаляет user.name если пользователь существует
Если объекта user нет - ошибка

Мы можем использовать ?. для безопасного ЧТЕНИЯ и УДАЛЕНИЯ, но не для записи !!!
=================================================================================
*/
