/*
 * Обработка ошибок, "try..catch"
 */
try {
  // "опасный" код
  // выполнение кода прерывается ошибкой
} catch (error) {
  // обработка ошибок
  // если их нет, этот блок пропускается
} finally {
  // код, который всегда выполняется
}

// ? try..catch работает синхронно !!!
try {
  setTimeout(function () {
    noSuchVariable; // скрипт упадёт тут
  }, 1000);
} catch (e) {
  alert("не сработает, движок уже покинет конструкцию try..catch");
}
/* Чтобы поймать исключение внутри запланированной функции, 
try..catch должен находиться внутри самой этой функции

?  error - объект ошибки
имеет два основных свойства:
name
- Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
message
- Текстовое сообщение о деталях ошибки.
stack (не везде поддерживается)
- Текущий стек вызова: строка, содержащая информацию о последовательности 
вложенных вызовов, которые привели к ошибке. Используется в целях отладки

error не обязателен, можно просто catch {}

?  throw new Error(message);
Генерация собственных ошибок

JavaScript позволяет вызывать throw с любыми аргументами, 
то есть технически наши классы ошибок не нуждаются в наследовании от Error
Но лучше все же применять наследование.

? finally
Блок finally срабатывает при любом выходе из try..catch, 
в том числе если там есть return.
Конструкция try..finally без секции catch также полезна. 
Мы применяем её, когда не хотим здесь обрабатывать ошибки (пусть выпадут), 
но хотим быть уверены, что начатые процессы завершились.

? Глобальный catch
Не является частью JS, но
в Node.js для выпавших ошибок есть process.on("uncaughtException"). 
А в браузере мы можем присвоить функцию специальному свойству 
window.onerror, которая будет вызвана в случае необработанной ошибки.

? window.onerror
window.onerror = function(message, url, line, col, error) {
...
};
message
- Сообщение об ошибке.
url
- URL скрипта, в котором произошла ошибка.
line, col
- Номера строки и столбца, в которых произошла ошибка.
error
- Объект ошибки.

? Проброс исключения 
– это очень важный приём обработки ошибок: блок catch обычно ожидает и знает, 
как обработать определённый тип ошибок, 
поэтому он должен пробрасывать дальше ошибки, о которых он не знает.
*/
